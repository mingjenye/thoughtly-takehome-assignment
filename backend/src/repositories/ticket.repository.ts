import pool from '../config/database';

export type TicketTier = 'VIP' | 'Front Row' | 'GA';
export type TicketStatus = 'available' | 'pending' | 'booked';

export interface Ticket {
  // TODO (Distributed Systems): Consider adding globally unique ID
  // Current: PostgreSQL SERIAL (auto-increment integer)
  //   - Works well for single-instance deployment
  //   - Limitation: Not globally unique across multiple databases/regions
  // 
  // For distributed systems, add:
  //   ticket_unique_id: string;  // Snowflake-like ID or UUID
  // 
  // Benefits of globally unique IDs:
  //   - Idempotent (same request = same ID)
  //   - No coordination needed across data centers
  //   - Safe for database sharding/partitioning
  //   - Merge-friendly across regions
  // 
  // See backend/README.md → "Ticket ID Strategy" for migration path
  id: number;
  event_id: number;
  tier: TicketTier;
  status: TicketStatus;
  user_id: number | null;
  booked_at: Date | null;
  created_at: Date;
  updated_at: Date;
}

export interface CreateTicketData {
  event_id: number;
  tier: TicketTier;
}

export class TicketRepository {
  /**
   * Create multiple tickets for an event
   * 
   * TODO (Distributed Systems): Generate globally unique IDs
   * 
   * Current: Relies on PostgreSQL SERIAL for ID generation
   *   - IDs generated by database (1, 2, 3...)
   *   - Simple but not globally unique
   * 
   * For distributed deployment, generate unique IDs before insertion:
   *   const tickets = ticketsData.map(t => ({
   *     ...t,
   *     ticket_unique_id: idGenerator.generateId().toString()
   *   }));
   * 
   * Then insert with unique IDs:
   *   INSERT INTO tickets (event_id, tier, ticket_unique_id) VALUES ...
   * 
   * This enables:
   *   - Cross-region ticket creation without ID collisions
   *   - Idempotent retry logic (same unique ID on retry)
   *   - Easy database sharding by ticket ID
   */
  async createBulk(tickets: CreateTicketData[]): Promise<Ticket[]> {
    const values = tickets.map(t => `(${t.event_id}, '${t.tier}')`).join(',');
    
    const result = await pool.query(
      `INSERT INTO tickets (event_id, tier) 
       VALUES ${values}
       RETURNING *`
    );
    
    return result.rows;
  }

  /**
   * Get all available tickets for an event grouped by tier
   */
  async findAvailableByEvent(eventId: number): Promise<Ticket[]> {
    const result = await pool.query(
      `SELECT * FROM tickets 
       WHERE event_id = $1 AND status = 'available'
       ORDER BY tier, id`,
      [eventId]
    );
    return result.rows;
  }

  /**
   * Get available tickets for an event and tier, filtering out Redis-locked tickets.
   *
   * TODO (Scaling): Implement Redis pre-filter for >50K concurrent users.
   *
   * Example implementation:
   *
   *   async function getAvailableTickets(eventId: number, tier: string) {
   *     // 1. Get locked tickets from Redis (fast)
   *     const lockedTickets = await redis.keys('ticket:*');
   *     const lockedIds = lockedTickets.map(k => k.split(':')[1]);
   *
   *     // 2. Query DB excluding locked tickets
   *     const placeholders = [eventId, tier];
   *     let query = `
   *       SELECT * FROM tickets 
   *       WHERE event_id = $1 
   *         AND tier = $2 
   *         AND status = 'available'
   *     `;
   *     if (lockedIds.length > 0) {
   *       // Dynamic placeholders for ids: $3, $4, ...
   *       const idPlaceholders = lockedIds.map((_, idx) => `$${idx + 3}`).join(',');
   *       query += ` AND id NOT IN (${idPlaceholders})`;
   *       placeholders.push(...lockedIds);
   *     }
   *     query += ` ORDER BY id`;
   *     const available = await db.query(query, placeholders);
   *
   *     return available.rows;
   *   }
   *
   * See README.md → "Preventing Double-Booking" for detailed analysis.
   */
  async getAvailableCountByTier(eventId: number, tier: TicketTier): Promise<number> {
    const result = await pool.query(
      `SELECT COUNT(*) as count FROM tickets 
       WHERE event_id = $1 AND tier = $2 AND status = 'available'`,
      [eventId, tier]
    );
    return parseInt(result.rows[0].count);
  }

  /**
   * Reserve a ticket (set status to pending)
   *
   * TODO (Scaling): Implement Redis Pre-filter for >50K concurrent
   *
   * Example implementation: see below.
   * 
   * See README.md → "Preventing Double-Booking" for detailed analysis
   */
  async reserveTicket(
    eventId: number,
    tier: TicketTier,
    userId: number,
    client: any
  ): Promise<Ticket | null> {
    // Find an available ticket with row-level lock
    // SKIP LOCKED ensures we skip tickets that are locked by other transactions
    const result = await client.query(
      `UPDATE tickets 
       SET status = 'pending', user_id = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = (
         SELECT id FROM tickets 
         WHERE event_id = $2 AND tier = $3 AND status = 'available'
         ORDER BY id
         LIMIT 1
         FOR UPDATE SKIP LOCKED
       )
       RETURNING *`,
      [userId, eventId, tier]
    );
    
    return result.rows[0] || null;
  }

  /**
   * Confirm ticket booking (set status to booked)
   */
  async confirmBooking(ticketId: number, client?: any): Promise<Ticket> {
    const dbClient = client || pool;
    
    const result = await dbClient.query(
      `UPDATE tickets 
       SET status = 'booked', booked_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
       WHERE id = $1
       RETURNING *`,
      [ticketId]
    );
    
    return result.rows[0];
  }

  /**
   * Cancel ticket reservation (set status back to available)
   */
  async cancelReservation(ticketId: number, client?: any): Promise<Ticket> {
    const dbClient = client || pool;
    
    const result = await dbClient.query(
      `UPDATE tickets 
       SET status = 'available', user_id = NULL, updated_at = CURRENT_TIMESTAMP
       WHERE id = $1
       RETURNING *`,
      [ticketId]
    );
    
    return result.rows[0];
  }

  /**
   * Find ticket by ID
   */
  async findById(ticketId: number): Promise<Ticket | null> {
    const result = await pool.query(
      'SELECT * FROM tickets WHERE id = $1',
      [ticketId]
    );
    return result.rows[0] || null;
  }

  /**
   * Get ticket with row-level lock (FOR UPDATE)
   */
  async findByIdForUpdate(ticketId: number, client: any): Promise<Ticket | null> {
    const result = await client.query(
      'SELECT * FROM tickets WHERE id = $1 FOR UPDATE',
      [ticketId]
    );
    return result.rows[0] || null;
  }

  /**
   * Get all tickets for a user
   */
  async findByUserId(userId: number): Promise<Ticket[]> {
    const result = await pool.query(
      `SELECT * FROM tickets 
       WHERE user_id = $1 AND status IN ('pending', 'booked')
       ORDER BY created_at DESC`,
      [userId]
    );
    return result.rows;
  }

  // ═══════════════════════════════════════════════════════════════════
  // REDIS LOCK APPROACH - FUTURE SCALING IMPLEMENTATION
  // ═══════════════════════════════════════════════════════════════════
  // 
  // The following methods are NOT implemented in current version,
  // but documented here to demonstrate scaling strategy for >50K concurrent.
  // 
  // See README.md → "Preventing Double-Booking → Option 1" for context.
  
  /**
   * TODO (Scaling): Recovery mechanism for Redis failure scenarios
   * 
   * PROBLEM: Redis Failure Scenarios
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * 
   * Scenario 1: Redis crashes during operation
   * - All in-memory locks lost
   * - Tickets appear available while users are still in payment
   * - Risk: Double booking on those tickets ❌
   * 
   * Scenario 2: Redis restart/failover
   * - Lock state lost if persistence not enabled
   * - Active reservations (users in payment flow) become invisible
   * - System shows tickets as available when they're actually reserved
   * 
   * Scenario 3: Network partition
   * - Application can't reach Redis
   * - Cannot acquire new locks
   * - Cannot query lock state
   * - System effectively down ❌
   * 
   * SOLUTION: Dual Storage + Recovery Mechanism
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * 
   * Hybrid Approach:
   * 1. Redis: Fast distributed locks (primary)
   * 2. DB: Persistent record (backup/recovery)
   * 3. Recovery: Rebuild Redis from DB on failure
   * 
   * Implementation Example:
   * 
   * // When reserving with Redis lock
   * async function reserveTicketWithRedis(ticketId, userId) {
   *   // 1. Acquire Redis lock (fast path)
   *   const locked = await redis.set(
   *     `ticket:${ticketId}`, userId, 'EX', 600, 'NX'
   *   );
   *   
   *   if (!locked) {
   *     throw new Error('Ticket already reserved');
   *   }
   *   
   *   // 2. Persist to DB for durability (important for recovery!)
   *   try {
   *     await db.query(`
   *       INSERT INTO pending_bookings (ticket_id, user_id, expires_at)
   *       VALUES ($1, $2, NOW() + INTERVAL '10 minutes')
   *       ON CONFLICT (ticket_id) DO NOTHING
   *     `, [ticketId, userId]);
   * 
   *   // Note: DB remains status='available'
   *   // Redis is source of truth for "reserved" state (= current DB status 'pending')
   *   // On confirm: Update DB to 'booked' + clear Redis
   *   // On timeout: Redis TTL expires (auto-release)
   * 
   *   } catch (error) {
   *     // If DB write fails, rollback Redis lock
   *     await redis.del(`ticket:${ticketId}`);
   *     throw error;
   *   }
   * }
   * 
   * // Recovery mechanism (on Redis failure)
   * async function recoverFromRedisFailure() {
   *   console.log('Redis failure detected, rebuilding lock state from DB...');
   *   
   *   // Load all active reservations from DB back to Redis
   *   // Only recover reservations that haven't expired yet
   *   const pending = await db.query(`
   *     SELECT 
   *       ticket_id, 
   *       user_id, 
   *       EXTRACT(EPOCH FROM (expires_at - NOW())) as ttl_seconds
   *     FROM pending_bookings
   *     WHERE expires_at > NOW()
   *   `);
   *   
   *   let recovered = 0;
   *   for (const booking of pending.rows) {
   *     try {
   *       // Restore lock to Redis with remaining TTL
   *       // Math.max(1, ttl) ensures at least 1 second TTL
   *       await redis.setex(
   *         `ticket:${booking.ticket_id}`,
   *         Math.max(1, Math.floor(booking.ttl_seconds)),
   *         booking.user_id
   *       );
   *       recovered++;
   *     } catch (error) {
   *       console.error(`Failed to recover ticket ${booking.ticket_id}:`, error);
   *     }
   *   }
   *   
   *   console.log(`Recovery complete: ${recovered} ticket locks restored`);
   *   
   *   // Clean up expired records from DB
   *   await db.query(`
   *     DELETE FROM pending_bookings
   *     WHERE expires_at < NOW()
   *   `);
   * }
   * 
   * WHY THIS MATTERS:
   * ────────────────
   * 
   * Without recovery:
   * - Redis crashes at 10:00 AM
   * - 1,000 users in payment flow (locks held in Redis)
   * - Redis restarts at 10:01 AM with empty state
   * - All 1,000 tickets show as available
   * - New users can book same tickets → DOUBLE BOOKING! ❌
   * 
   * With recovery:
   * - Redis crashes at 10:00 AM
   * - Recovery runs automatically on Redis reconnect
   * - Loads 1,000 active reservations from pending_bookings table
   * - Restores locks to Redis with remaining TTL
   * - System continues normally → NO DOUBLE BOOKING ✅
   * 
   * RECOVERY TRIGGERS:
   * ──────────────────
   * 1. Redis reconnection after crash
   * 2. Application startup (load existing state)
   * 3. Periodic health check (detect drift)
   * 4. Manual trigger (ops tool)
   * 
   * ADDITIONAL CONSIDERATIONS:
   * ──────────────────────────
   * 
   * 1. Race condition during recovery:
   *    - User completes payment while recovery running
   *    - Solution: Use Redis NX flag (only set if not exists)
   * 
   * 2. DB table needed:
   *    CREATE TABLE pending_bookings (
   *      ticket_id INT PRIMARY KEY,
   *      user_id INT NOT NULL,
   *      created_at TIMESTAMP DEFAULT NOW(),
   *      expires_at TIMESTAMP NOT NULL,
   *      INDEX idx_expires (expires_at)
   *    );
   * 
   * 3. Cleanup job for expired records:
   *    - Cron job every 5 minutes
   *    - DELETE FROM pending_bookings WHERE expires_at < NOW()
   *    - Keeps table size manageable
   * 
   * 4. Redis persistence configuration:
   *    - Enable AOF (Append-Only File) for durability
   *    - Enable RDB snapshots as backup
   *    - Reduces need for recovery (data survives restart)
   * 
   * TRADE-OFF ANALYSIS:
   * ───────────────────
   * 
   * | Aspect | Redis-Only | Redis + DB Backup |
   * |--------|-----------|-------------------|
   * | **Write Latency** | 1-2ms ✅ | 10-15ms (Redis + async DB) |
   * | **Recovery** | ❌ Data loss on crash | ✅ Full recovery possible |
   * | **Complexity** | Simple | Medium (two systems) |
   * | **Durability** | ❌ Volatile | ✅ Persistent |
   * | **Best For** | Non-critical locks | Critical bookings ✅ |
   * 
   * 
   * See README.md → "Scalability Considerations → Redis-Based Ticket Lock"
   */
}

